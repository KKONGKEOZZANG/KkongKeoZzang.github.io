---
title: "Baekjoon 문제 풀기 (2775번 : 부녀회장이 될테야) Python"
use_math: true
categories:
  - baekjoon
  - algorithm
  - bronze2
  - retry
tags:


---


# [2775번 : 부녀회장이 될테야](https://www.acmicpc.net/problem/2775)



#### 1. 문제읽기
---

> 문제 좀 제대로 읽자.   

다짐한다.   
앞으로는 절대 1문제 당 30분을 넘기지 않을 것이다.  
넘기면 네 발로 걸어다닐 거다.  



진짜 너무 답이 보기 싫어서 거의 2시간 넘게 문제에 매달렸는데, 지고 말았다.  
심지어는 문제 자체도 이해를 잘못했다............  
a층의 b호는 자신의 아래층의 1~b호의 사람 수의 합이다.  
조건이 다 나와있는데도 자신의 아래층이 아니라 0~a-1층까지 각각 1~b호 사람 수의 합인줄 알았다.  

심지어 문제 접근 방법도 이중배열과 3중 for문을 써서 너무 복잡하고 어려웠다.  
index 범위 오류도 계속 떠서 제대로 된 코드도 만들지 못했다.  
잘못 푼 코드도 정리해볼까 했지만 문제 자체를 잘못 읽어서 필요 없을 것 같다...  




#### 2. 제출 코드 
---

와! 답을 봤는데도 이해하는데 한참 걸렸다.  
결국 오카방의 도움까지 빌려서야 겨우 이해를 끝냈다.  



1. 테스트 케이스 몇 번 받을 것인지 반복문 사용  
	층수는 k, 호수는 n으로 받는다.  
	예 ) 2층 3호의 사람 수 구하기
2. 0 층의 사람 수를 리스트로 먼저 만든다.  
	예 ) apt = [1, 2, 3]  
3. 층 수 만큼 반복문을 돌려준다.  
	예 ) 2층까지 리스트를 만들어야 하기 때문에 1번 반복 - 1층 만들기, 2번 반복 - 2층 만들기  
4. **제일 이해 안갔던 부분!!! 왜!!! 1부터 시작인가!!!**  
	이해하는 방법은 2가지가 있다.  
	* 0-base : 인덱스 0 부터 시작 (0번 인덱스 = 1호)   
	
	* 1-base : 인덱스 1 부터 시작 (1번 인덱스 = 1호)  
	

	나는 0-base로 접근했고, 정답 코드는 1-base로 접근해서 이해가 바로 되지 않았다.  
	0호가 없기 때문에 1번 인덱스부터 시작하는 것이 더 직관적이라 많이 선호하는 듯 하다.  
	0번 인덱스는 존재하지만, 문제 풀 때는 없이 취급을 해도 상관없다.  
	나는 그게 좀 이상해서 그냥 0번 인덱스를 꼭 채워서 문제를 이해하려 했는데, 이것 때문에 꼬인 것 같다.  
5. 아래층 호수 값들을 다 더해준 값이 현재층 호수의 값이 된다.  
	예 ) 0-base : 1호의 값은 어차피 0번 인덱스 값으로 동일하기 때문에, 2호(1번 인덱스)값 부터 채워준다.  
	예 ) 1-base : 1호 값은 0호(없는 값), 2호 값은 0호+1호, 3호 값은 0+1+2호 이렇게 차례로 채워준다.  
6. 가장 마지막 층, 가장 마지막 호수의 값이 정답이므로 출력해준다.  

	

```python
t = int(input()) 


for _ in range(t):  # 1
    k = int(input())
    n = int(input())
    apt = [p for p in range(1, n+1)]  # 2
    for _ in range(k):  # 3
        for i in range(1, n):  # 4 
            apt[i] += apt[i-1]  # 5
    print(apt[-1])  # 6
```





#### 3. 공부할 것
---

나는 알고리즘 문제를 풀 때, 처음부터 끝까지 모든 값을 정리해서 풀려는 생각이 강하다.  
이번 문제도 사실 층 수는 한개로 두고 계속 갱신해나가면서 답을 찾는 방법이였는데, 나는 0층부터 k층까지 모든 값을 리스트로 만들어두고 출력하려고 했다.  
값을 갱신하는 개념이 아직 익숙하지 않아 계속 틀리는 것 같다.  
저번에 틀린 문제도 그랬던 것 같은데...  



잊어버릴 때 쯤 다시 풀어봐야겠다.  

